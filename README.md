# dbt Core + BigQuery 実践ブートキャンプ：Jaffle Shop再生計画 🥪

## 🎬 シナリオ：あなたのミッション

**【設定】**
あなたは、急成長中のホットサンドデリバリー「**Jaffle Shop**」に、一人目の**アナリティクス・エンジニア**として入社しました。
これまではエンジニアが片手間でSQLを書いていましたが、データの定義がバラバラで、CEOが見るダッシュボードの数字がおかしいという問題が発生しています。

**【あなたのミッション】**
汚い生データを整理し、信頼できるデータマート（分析用テーブル）を構築すること。そして、その基盤をチームに展開すること。

---

## 🟢 第1問：環境構築と接続テスト

最初の面接課題（実技試験）です。
まずは手元の開発環境を整え、データウェアハウス（BigQuery）と「握手」してください。

**要件:**
1.  作業ディレクトリを作成する。（例: \`jaffle_shop\`）
2.  Python仮想環境を作成し、\`dbt-bigquery\` アダプターをインストールする。
3.  \`dbt init\` コマンドを使用して、新しいdbtプロジェクト（プロジェクト名: \`jaffle_shop\`）の雛形を作成する。
4.  BigQueryの接続設定を行い、\`dbt debug\` コマンドで**接続成功（All checks passed!）**を確認する。

---

## 🟢 第2問：データの種まき (Seeding)

環境は整いましたが、肝心のデータが空っぽです。エンジニアチームのリーダーからSlackが届きました。

> **リーダー:**
> 「お疲れ！とりあえず分析用のサンプルデータをCSVで送るね。
> これをBigQueryに入れておいてくれる？ 手動アップロードじゃなくて、**dbtの管理下で**入れといてね。
> あと、データ型とかは適当によろしく！」

**【あなたのミッション】**
dbtの **"Seed"** 機能を使って、手元のCSVファイルをBigQuery上のテーブルとしてロードしてください。

**データ素材（コピーして作成）:**
- \`seeds/raw_customers.csv\` (顧客マスタ)
- \`seeds/raw_orders.csv\` (注文履歴)
※ データの中身は \`answer_key/jaffle_shop/seeds/\` を参照してください。

**【完了条件】**
- \`dbt seed\` コマンドが成功すること。
- BigQuery上にテーブルが作成されていること。

---

## 🟢 第3問：ステージング層（Staging Layer）の構築

さて、データは入りましたが、今のままでは使いにくい状態です。
\`raw_customers\` の \`id\` と \`raw_orders\` の \`id\` は、同じ「id」というカラム名ですが意味が違います（顧客IDと注文ID）。結合するときに混乱の元ですね。

dbtのベストプラクティスでは、生データをそのまま使うのではなく、**「Staging（ステージング）層」**という薄い層を挟んで、カラム名の変更や型の統一を行うのが鉄則です。

**【あなたのミッション】**
\`models/staging/\` ディレクトリに以下のSQLモデルを作成してください。

1.  **\`stg_customers.sql\`**:
    - \`id\` → \`customer_id\` にリネーム
2.  **\`stg_orders.sql\`**:
    - \`id\` → \`order_id\` にリネーム
    - \`user_id\` → \`customer_id\` にリネーム（ここ重要！結合キーの名前を合わせます）

**【完了条件】**
- \`dbt run\` が成功すること。
- 参照には必ずジンジャ関数 \`{{ ref('...') }}\` を使用すること。

---

## 🟢 第4問：データマートの作成（結合と計算）

いよいよここからが本番です。CEOからの質問に答えるための集計テーブル（データマート）を作ります。

> **CEO:**
> 「顧客ごとの『生涯価値（LTV）』が見たいんだ。
> 具体的には、**顧客ID、氏名、最初の注文日、直近の注文日、注文回数** が一覧になっているテーブルを作ってくれ。」

**【あなたのミッション】**
\`models/marts/customers.sql\` を作成し、以下のロジックを実装してください。

**要件:**
1.  \`stg_customers\` と \`stg_orders\` を結合する。
2.  顧客ごとに注文データを集計（min, max, count）する。
3.  注文がない顧客は、注文回数が「NULL」ではなく「0」になるようにする（\`coalesce\`関数などを使用）。

**【完了条件】**
- \`dbt run\` が成功すること。
- 「Kobe B. さんは注文回数が1回」、「LeBron J. さんの注文回数は0回」になっていることを確認する。

---

## 🟢 第5問：品質テスト（自動テストの実装）

データマートはできましたが、ここで事件発生です。

> **CEO:**
> 「ありがとう！見てみたんだけど、なんか一部の注文データの整合性が怪しい気がするんだよね…。
> 前任者のときは、存在しないユーザーIDで注文が作られてたりして、集計がズレて困ったんだよ。
> **二度と変なデータが紛れ込まないように、品質を保証する仕組み**を入れてくれないか？」

**【あなたのミッション】**
\`models/schema.yml\` を作成し、以下のテストを実装してください。

1.  **一意性チェック**: IDカラムが重複していないこと (\`unique\`)
2.  **欠損チェック**: IDカラムがNULLでないこと (\`not_null\`)
3.  **参照整合性チェック**: 注文データの顧客IDが、必ず顧客マスタに存在すること (\`relationships\`)

**【ヒント】**
今回のサンプルデータには、**マスタに存在しない顧客（ID: 99）による注文**が紛れ込んでいます。テストが正しく実装されていれば、エラーが出るはずです！

---

## 🟢 最終問題：ドキュメント生成と可視化

CEOは大変満足していますが、エンジニアチームから要望が来ました。

> **エンジニアチーム:**
> 「データマートは便利だけど、正直どのテーブルが何なのか、どのカラムが何を意味するのか、いちいち聞くのが面倒なんだよね。
> **ドキュメント**ってある？ あと、このテーブルがどこから来てるのかわかる図とかない？」

**【あなたのミッション】**
dbtの標準機能を使って、ドキュメントサイトを生成してください。

**【完了条件】**
- \`dbt docs generate\` でドキュメントを生成する。
- \`dbt docs serve\`（または生成された \`target/index.html\`）で、テーブル定義やリネージ（依存関係図）が可視化されていることを確認する。

---

## 🏁 ゴール
おめでとうございます！これで「Jaffle Shop」のデータ基盤は盤石なものになりました。
あなたはdbtエンジニアとしての第一歩を踏み出しました。

### 📂 解答例
行き詰まったときは、\`answer_key/\` ディレクトリにある模範解答を参照してください。
